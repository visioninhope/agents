---
title: Core concepts of the Inkeep Agent Platform
sidebarTitle: Concepts
description: Learn about the key building blocks of Inkeep - agents, graphs, tools, data components, and more.
icon: "LuBoxes"
---

## Agents, Tools

Inkeep is designed with Agents as the primary building blocks of AI systems.

In simple terms:
- An **Agent** is an LLM (AI model) that receives a message and can use tools or collaborate with other agents to accomplish a goal.
- **Tools** are actions that an Agent can take, like looking up information or taking an action on third-party systems and APIs.

In Inkeep, tools are added to agents as **MCP Servers**. Many services provide out-of-the-box MCP Servers, but you can also create your own. You can register MCP servers and their associated **Credentials**, then use them within Graphs.

Typically, you want an Agent to handle narrow, well-defined tasks. Keeping the scope narrow allows you to optimize your **prompt** (instructions) and the tools an agent has to be specific to a scenario or task. As a general rule of thumb, only add up to 5-7 tools to an agent.

## Graphs

When what you're trying to accomplish gets complex, it can be useful to break up your logic into a "team" of agents that work together. 

At Inkeep, we call that a **Graph**. A Graph is made up of one or more Agents that collaborate to complete a task and respond to the user.

<Tip>
**You can treat a Graph as one Agent**: when you send a message, it'll sound and reply as one single Agent, even if internally it's coordinating across multiple agents. This is similar to how companies operate: there may be internal back-and-forths between employees, but a company acts as one cohesive unit to external audiences, like customers.
</Tip>

### Agent to Agent relationships

With Inkeep, every Graph has a **Default Agent** that receives the initial message and decides how to proceed. 

In a Graph, an Agent can choose to:
- **Transfer** control of the chat to another Agent so a different Agent can respond to the user.
- **Delegate** a subtask for another Agent to do and wait for its response before proceeding with the next step.
 
### Agent 'turn'

In summary, when an Agent receives a message, it can choose to:
1. Respond to the user
2. Call a tool to collect information or take an action 
3. Transfer or delegate to another Agent

The Graph keeps executing steps 2 and 3 until an Agent in the graph chooses to respond to the user with a final result or a next message.

## Chatting with an Agent

<Snippet file="multi-agent-framework/WaysToTalkToGraph.mdx" />

## Authentication & API Keys

You can authenticate with your graph using:

- **API Keys**: Securely hashed keys that are scoped to specific graphs
- **Development Mode**: No API key required, perfect for local development and testing
- **Bypass Secrets**: For internal services and infrastructure that need direct access

API keys are the recommended approach for production use, providing secure, scoped access to your agent graphs.

## Agent replies with Structured Data

- **Data Components**: Structured pieces of information (JSON) that agents can output in their messages so they can render rich, interactive UIs (lists, buttons, forms, etc.) or convey structured information.
- **Artifacts**: Structured pieces of information (JSON) *from a tool call* that an Agent can save and make available to others. For example, an Agent can save a webpage it looked at as an artifact. Once saved, an Agent can cite or reference artifacts in its responses, and other agents or users can fetch the full artifacts if they'd like.
- **Status Updates**: Real-time progress indicators powered by AI that keep users informed about what the agent is doing during longer operations.

## Passing context to Agents

Agents have a few ways of getting information:
- **Headers**: In the API request to an Agent, the calling application can include headers (aka **Request Context**) for an agent.
- **Context Fetchers**: Can be configured at the Graph level to always fetch information. For example, your Headers may include a `user-id`, which can then be used to fetch information about that user from a CRM. These happen without the need for Tool Calls.

Headers and fetched context can then be referenced explicitly as `{{variables}}` in Agent prompts. Learn more [here](/typescript-sdk/request-context).

## Ways to build

Quick reference to the key docs for building with the Visual Builder or the Agents SDK.

<Tabs>
  <Tab title="Visual Builder">
    <Cards>
      <Card title="MCP Servers" icon="LuServer" href="/visual-builder/mcp-servers">
        Configure and manage MCP servers for your agents.
      </Card>
      <Card title="Graphs" icon="LuSpline" href="/visual-builder/graphs">
        Create and manage agent graphs visually.
      </Card>
      <Card title="Data Components" icon="LuLayoutTemplate" href="/visual-builder/data-components">
        Build rich UI elements agents can render in conversations.
      </Card>
      <Card title="Artifact Components" icon="TbInputSpark" href="/visual-builder/artifact-components">
        Define structured outputs generated by tools or agents.
      </Card>
      <Card title="Status Components" icon="LuClock" href="/visual-builder/status-components">
        Show progress updates during longer operations.
      </Card>
      <Card title="Credentials" icon="LuKey" href="/visual-builder/credentials">
        Manage secrets and auth for MCP servers.
      </Card>
      <Card title="Project Management" icon="LuFolder" href="/visual-builder/project-management">
        Organize graphs, MCP Servers, and other entities in Projects.
      </Card>
    </Cards>
  </Tab>
  <Tab title="Agents SDK">
    <Cards>
      <Card title="Agent Settings" icon="LuUser" href="/typescript-sdk/agent-configuration">
        Configure agents with prompts, tools, and data components.
      </Card>
      <Card title="MCP Servers" icon="LuHammer" href="/typescript-sdk/tools-and-mcp-servers">
        Add tools as MCP servers.
      </Card>
      <Card title="Agent Relationships" icon="LuUsers" href="/typescript-sdk/agent-relationships">
        Define how agents transfer and delegate tasks.
      </Card>
      <Card title="Data Components" icon="LuLayoutTemplate" href="/typescript-sdk/data-components">
        Build custom UI elements agents can render.
      </Card>
      <Card title="Artifact Components" icon="TbInputSpark" href="/typescript-sdk/artifact-components">
        Create structured outputs from tools or agents.
      </Card>
      <Card title="Status Updates" icon="LuClock" href="/typescript-sdk/status-updates">
        Provide real-time progress updates.
      </Card>
      <Card title="Context Fetchers" icon="LuCirclePlus" href="/typescript-sdk/context-fetchers">
        Dynamically fetch and cache external context.
      </Card>
      <Card title="Credentials" icon="LuKey" href="/typescript-sdk/credentials">
        Store and retrieve credentials for MCP tools.
      </Card>
    </Cards>
  </Tab>
</Tabs>

The Visual Builder and TypeScript SDK work seamlessly together—define your agents in code, push them to the visual builder, and iterate visually.

## Projects

You can organize your related MCP Servers, Credentials, Graphs, and more into **Projects**. A Project is generally used to represent a set of related scenarios. 

For example, you may create one Project for your support team that has all the MCP servers and Graphs related to customer support. 

## CLI: Push and pull

The Inkeep CLI bridges your TypeScript SDK project and the Visual Builder.

Run the following from your project (the folder that contains your `inkeep.config.ts`) and has an `index.ts` file that exports a project.

- **Push (code → Builder)**: Sync locally defined graphs, agents, tools, and settings from your SDK project into the Visual Builder.

```bash
inkeep push
```

- **Pull (Builder → code)**: Fetch your project from the Visual Builder back into your SDK project. By default, the CLI will LLM-assist updating your local TypeScript files to reflect Builder changes.

```bash
inkeep pull
```

<Note>
Push and pull operate at the project level (not individual graphs). Define graphs in your project and push/pull the whole project.
</Note>

See the [CLI Reference](/typescript-sdk/cli-reference) for full command details.


