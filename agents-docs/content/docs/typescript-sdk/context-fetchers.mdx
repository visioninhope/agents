---
title: Context Fetchers
description: Learn how to use context fetchers to fetch data from external sources and make it available to your agents
icon: "LuCirclePlus"
---

## Overview

Context fetchers allow your agents to access real-time data from external APIs. Instead of hardcoding information in your agent prompt, context fetchers dynamically retrieve fresh data for each conversation.

## Key Features

- **Dynamic data retrieval**: Fetch real-time data from APIs.
- **Template interpolation**: Use context variables in agent prompts.
- **Request context integration**: Use request-specific parameters to customize data fetching.
- **Data transformation**: Transform API responses into the exact format your agent needs.

## When to Use Context Fetchers

Context fetchers are perfect when your agents need:
- **User data**: "Hello John, here are your recent orders..."
- **Real-time info**: Current weather, stock prices, system status
- **External APIs**: CRM data, inventory levels, user permissions
- **Dynamic content**: Personalization based on request headers

Instead of hardcoding data, context fetchers fetch it fresh for each conversation.

## Basic Usage

Let's create a simple context fetcher that retrieves user information:

```typescript
import { z } from "zod";
import {
  agent,
  agentGraph,
  contextConfig,
  fetchDefinition,
} from "@inkeep/agents-manage-api/builders";

// 1. Define request schema for headers validation. All header keys are converted to lowercase.
// In this example all incoming headers will be validated to make sure they include user_id and api_key.
const requestSchema = z.object({
  user_id: z.string(),
  api_key: z.string(),
});

// 2. Create the fetcher
const userFetcher = fetchDefinition({
  id: "user-info",
  name: "User Information",
  trigger: "initialization", // Fetch only once when a conversation is started with the graph. When set to "invocation", the fetch will be executed every time a request is made to the graph.
  fetchConfig: {
    url: "https://api.example.com/users/{{requestContext.user_id}}",
    method: "GET",
    headers: {
      Authorization: "Bearer {{requestContext.api_key}}",
    },
    transform: "name", // Extract user's name from response, for example if the response is { "name": "John Doe", "email": "john.doe@example.com" }, the transform will return "John Doe"
  },
  responseSchema: z.string(), // Used to validate the result of the transformed api response.
  defaultValue: "Unable to fetch user information",
});

// 3. Configure context
const userContext = contextConfig({
  tenantId: "your-tenant",
  id: "user-context",
  name: "User Context",
  description: "Fetches user information for personalization",
  requestContextSchema: requestSchema, 
  contextVariables: {
    userName: userFetcher,
  },
});

// 4. Create and use the agent
const personalAgent = agent({
  id: "personal-agent",
  name: "Personal Assistant",
  description: "A personalized AI assistant",
  prompt: "Hello {{userName}}! I'm your personal assistant.",
});
```

### Using the Context Fetcher

```typescript
// Initialize the graph
export const graph = agentGraph({
  id: "personal-graph",
  name: "Personal Assistant Graph",
  defaultAgent: personalAgent,
  agents: () => [personalAgent],
  contextConfig: userContext,
});
```

## Using Context Variables

Use double curly braces `{{}}` to reference request context variables. 
You can embed request variables in fetch definitions and agent prompts using the key `requestContext`:

```typescript
const requestSchema = z.object({
  user_id: z.string(),
  org_alias: z.string()
  auth_token: z.string(),
});

const fetchDef = fetchDefinition({
  // ... other properties
  url: "https://api.example.com/users/{{requestContext.user_id}}",
  headers: {
    Authorization: "Bearer {{requestContext.auth_token}}",
    "X-Org-Alias": "{{requestContext.org_alias}}",
  },
  responseSchema: z.object({
    name: z.string(),
    email: z.string(),
  }),
});
```

You can embed fetched data in agent prompts using the key defined in `contextVariables`:

```typescript
const userContext = contextConfig({
  tenantId: "your-tenant",
  id: "user-context",
  name: "User Context",
  description: "Fetches user information for personalization",
  requestContextSchema: requestSchema,
  contextVariables: {
    user: fetchDef,
  },
});

const personalAgent = agent({
  id: "personal-agent",
  name: "Personal Assistant",
  description: "A personalized AI assistant",
  prompt: "Hello {{user.name}}! I'm your personal assistant. I can see that you work for {{requestContext.org_alias}}",
});
```


## Data transformation

The `transform` property on fetch definitions lets you extract exactly what you need from API responses using JMESPath notation:

```typescript
// API returns: { "user": { "profile": { "displayName": "John Doe" } } }
transform: "user.profile.displayName"; // Result: "John Doe"

// API returns: { "items": [{ "name": "First Item" }, { "name": "Second Item" }] }
transform: "items[0].name"; // Result: "First Item"
```

## Best Practices

1. **Use Appropriate Triggers**

   - `initialization`: Use when data rarely changes
   - `invocation`: Use for frequently changing data

2. **Handle Errors Gracefully**

   - Always provide a `defaultValue`
   - Use appropriate response schemas

## Common Issues

- **"Context Validation Failed"**: Check your request context schema and response schemas.
- **"F"**: Verify URL and add `defaultValue`